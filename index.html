<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ— å°½è¿·åŸŸ - ç§»åŠ¨ç«¯åŠ©æ‰‹</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #2b6cb0;
            --accent-color: #e53e3e;
            --heal-color: #38a169;
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #2d3748;
            --text-sub: #718096;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        /* å…¨å±€ç¦ç”¨æŒ‰é’®/è¾“å…¥çš„åŒå‡»ç¼©æ”¾ */
        button, input, select, .btn-upload, .monster-list-btn, .fab-btn, .close-btn {
            touch-action: manipulation; 
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 12px;
            padding-bottom: 80px;
            color: var(--text-main);
        }

        /* --- é¡¶éƒ¨æ§åˆ¶æ  --- */
        .controls {
            background: white;
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            z-index: 90;
        }

        .status-bar {
            font-size: 0.85em;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* å¸ƒå±€æ§åˆ¶è¡Œ */
        .control-row {
            display: flex;
            gap: 8px; /* é—´è·ç¼©å° */
            align-items: flex-end;
        }

        /* å·¦ä¾§ï¼šä¸»è¦åŒºåŸŸï¼Œå æ®å‰©ä½™æ‰€æœ‰ç©ºé—´ */
        .group-main {
            flex: 1;
            min-width: 0; /* é˜²æ­¢å†…å®¹æ’‘ç ´ */
        }

        /* å³ä¾§ï¼šå›ºå®šçª„å®½åº¦ */
        .group-side {
            flex: 0 0 100px; /* å›ºå®šä¸º100pxå®½ */
            width: 100px;
        }

        .input-group label {
            display: block;
            font-size: 0.75em;
            color: var(--text-sub);
            margin-bottom: 4px;
            font-weight: 600;
            white-space: nowrap; /* é˜²æ­¢æ¢è¡Œ */
        }

        select, input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            background: #f8fafc;
            appearance: none;
            height: 40px; /* ç¨å¾®è°ƒä½é«˜åº¦ */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- ç­‰çº§æ§åˆ¶ç»„åˆæ ·å¼ --- */
        .level-control-wrapper {
            display: flex;
            align-items: center;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: #f8fafc;
            overflow: hidden;
            height: 40px; /* ç¨å¾®è°ƒä½é«˜åº¦ */
            width: 100%; 
        }

        .level-btn {
            width: 30px; /* æŒ‰é’®å˜çª„ */
            height: 100%;
            background: #e2e8f0;
            border: none;
            font-weight: bold;
            font-size: 1.2em;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            cursor: pointer;
            transition: background 0.1s;
        }

        .level-btn:active { background: #cbd5e0; }

        .level-control-wrapper input[type="number"] {
            border: none;
            text-align: center;
            background: transparent;
            font-weight: 800;
            flex: 1;
            height: 100%;
            padding: 0;
            border-radius: 0;
            font-size: 1.1em;
            -moz-appearance: textfield;
            min-width: 0;
        }

        .level-control-wrapper input::-webkit-outer-spin-button,
        .level-control-wrapper input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* æ–‡ä»¶ä¸Šä¼ æŒ‰é’® */
        .file-upload-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .file-upload-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        
        .btn-upload {
            display: block;
            background: white;
            border: 1px dashed var(--primary-color);
            color: var(--primary-color);
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
        }

        /* --- å¡ç‰‡åŒºåŸŸ --- */
        .cards-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
        }

        .card.boss-card {
            border: 2px solid var(--accent-color);
            background: #fffcfc;
        }
        
        .card.boss-card::after {
            content: "BOSS";
            position: absolute;
            top: 10px;
            right: -20px;
            background: var(--accent-color);
            color: white;
            font-size: 0.7em;
            padding: 2px 25px;
            transform: rotate(45deg);
            box-shadow: 0 2px 2px rgba(0,0,0,0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            padding-right: 20px;
        }

        .card-title {
            font-size: 1.25em;
            font-weight: 800;
            color: #1a202c;
        }

        .card-meta {
            font-size: 0.8em;
            color: var(--text-sub);
            margin-top: 2px;
            display: flex;
            gap: 8px;
        }
        .meta-tag { background: #edf2f7; padding: 2px 6px; border-radius: 4px; }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #edf2f7;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: #718096;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            cursor: pointer;
        }
        .boss-card .close-btn { 
            left: unset; right: 10px; top: 40px; 
        }

        /* å±æ€§ç½‘æ ¼ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            background: #f7fafc;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .stat-item { display: flex; flex-direction: column; }
        .stat-label { font-size: 0.7em; color: var(--text-sub); margin-bottom: 2px; }
        .stat-value { font-size: 1.1em; font-weight: 800; color: var(--text-main); }

        /* HP æ§åˆ¶æ¡ */
        .hp-control {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .hp-display {
            text-align: center;
            font-size: 1.4em;
            font-weight: 800;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .hp-actions {
            display: flex;
            gap: 8px;
            height: 44px;
        }

        .hp-input {
            width: 50px !important;
            text-align: center;
            font-weight: bold;
            padding: 0;
            border-color: #cbd5e0;
            height: 100%;
        }

        .hp-btn {
            flex: 1;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1em;
            color: white;
            box-shadow: 0 2px 2px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .hp-btn:active { transform: scale(0.98); }
        .hp-btn.damage { background: var(--accent-color); }
        .hp-btn.heal { background: var(--heal-color); }

        /* ç‰¹æ•ˆæ–‡æœ¬ */
        .effect-text {
            font-size: 0.9em;
            line-height: 1.5;
            color: #4a5568;
            background: #fffff0;
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #ecc94b;
        }

        /* --- åº•éƒ¨æŠ½å±‰ --- */
        .fab-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--primary-color);
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            z-index: 200;
            border: none;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .fab-btn:active { transform: scale(0.9); }

        .drawer-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 299;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .drawer-overlay.active { display: block; opacity: 1; }

        .bottom-drawer {
            position: fixed;
            left: 0; right: 0; bottom: 0;
            background: white;
            z-index: 300;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 -4px 10px rgba(0,0,0,0.1);
        }
        .bottom-drawer.active { transform: translateY(0); }

        .drawer-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            text-align: center;
            font-weight: bold;
            color: var(--text-sub);
        }

        .drawer-content {
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch; 
        }

        .monster-list-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: #f7fafc;
            border: 1px solid #edf2f7;
            border-radius: 8px;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            cursor: pointer;
        }
        .monster-list-btn:active { background: #e2e8f0; }
        
        .tag { font-size: 0.75em; padding: 2px 6px; border-radius: 4px; color: white; }
        .tag-boss { background: var(--accent-color); }
        .tag-mob { background: #718096; }

        .empty-state {
            text-align: center;
            color: #a0aec0;
            margin-top: 50px;
            padding: 20px;
        }
        
        .status-success { color: #38a169; }
        .status-error { color: #e53e3e; }
    </style>
</head>
<body>

<div class="controls">
    <div class="file-upload-wrapper" id="uploadWrapper">
        <label class="btn-upload">
            ğŸ“‚ ç‚¹å‡»ä¸Šä¼  Excel æ–‡ä»¶
            <input type="file" id="fileUpload" accept=".xlsx, .xls" />
        </label>
    </div>

    <div class="status-bar">
        <span id="statusMessage" style="color:#718096">ç­‰å¾…åŠ è½½...</span>
    </div>

    <div class="control-row">
        <div class="input-group group-main">
            <label>å½“å‰åŒºåŸŸ</label>
            <select id="dungeonSelect" onchange="renderMonsterList()">
                <option value="">(æ— æ•°æ®)</option>
            </select>
        </div>
        
        <div class="input-group group-side">
            <label>ç­‰çº§</label>
            <div class="level-control-wrapper">
                <button class="level-btn" onclick="changeLevel(-1)">-</button>
                <input type="number" id="levelInput" value="1" min="1" onchange="updateAllCards()">
                <button class="level-btn" onclick="changeLevel(1)">+</button>
            </div>
        </div>
    </div>
</div>

<div class="cards-area" id="cardsArea">
    <div class="empty-state">
        <p>ç‚¹å‡»å³ä¸‹è§’ + å·æ·»åŠ æ€ªç‰©</p>
    </div>
</div>

<button class="fab-btn" onclick="toggleDrawer(true)">+</button>

<div class="drawer-overlay" id="drawerOverlay" onclick="toggleDrawer(false)"></div>
<div class="bottom-drawer" id="bottomDrawer">
    <div class="drawer-header">é€‰æ‹©æ€ªç‰© (ç‚¹å‡»æ·»åŠ )</div>
    <div class="drawer-content" id="monsterList">
        <div style="text-align:center; padding:20px; color:#aaa;">è¯·å…ˆåŠ è½½æ–‡ä»¶æ•°æ®</div>
    </div>
</div>

<script>
    let rawData = {};
    let cardIdCounter = 0;
    let activeCards = {};

    document.addEventListener("DOMContentLoaded", () => {
        autoLoadFile(); 
    });

    document.getElementById('fileUpload').addEventListener('change', handleFileSelect, false);

    async function autoLoadFile() {
        const statusEl = document.getElementById('statusMessage');
        statusEl.innerText = "æ­£åœ¨å°è¯•è‡ªåŠ¨åŠ è½½...";
        
        try {
            const response = await fetch('æ— å°½è¿·åŸŸ.xlsx');
            if (!response.ok) throw new Error("æœªæ‰¾åˆ°é»˜è®¤æ–‡ä»¶");
            
            const arrayBuffer = await response.arrayBuffer();
            const workbook = XLSX.read(new Uint8Array(arrayBuffer), {type: 'array'});
            
            processWorkbook(workbook);
            
            statusEl.className = 'status-success';
            statusEl.innerText = "å·²è‡ªåŠ¨åŠ è½½: æ— å°½è¿·åŸŸ.xlsx";
            document.getElementById('uploadWrapper').style.display = 'none'; 
        } catch (err) {
            console.log("è‡ªåŠ¨åŠ è½½å¤±è´¥:", err);
            statusEl.innerText = "è¯·ä¸Šä¼ æ•°æ®æ–‡ä»¶";
            statusEl.className = '';
        }
    }

    function handleFileSelect(evt) {
        const file = evt.target.files[0];
        if (!file) return;

        const statusEl = document.getElementById('statusMessage');
        statusEl.innerText = `è¯»å–ä¸­: ${file.name}...`;

        const reader = new FileReader();
        
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                processWorkbook(workbook);
                statusEl.className = 'status-success';
                statusEl.innerText = `åŠ è½½æˆåŠŸ`;
                document.getElementById('uploadWrapper').style.display = 'none';
            } catch (err) {
                console.error(err);
                statusEl.className = 'status-error';
                statusEl.innerText = `é”™è¯¯: ${err.message}`;
            }
        };
        reader.readAsArrayBuffer(file);
    }

    function processWorkbook(workbook) {
        rawData = {};
        let loadedSheets = 0;

        workbook.SheetNames.forEach(sheetName => {
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });

            if (jsonData.length > 0) {
                const headers = Object.keys(jsonData[0]);
                const requiredHeaders = ['Name', 'Type', 'Agility', 'Retention', 'Effect'];
                const isValidSheet = requiredHeaders.filter(h => headers.includes(h)).length >= 3;

                if (isValidSheet) {
                    const monsters = jsonData.filter(row => 
                        row.Type && (row.Type.trim() === 'æ€ªç‰©' || row.Type.trim() === 'é¦–é¢†')
                    );
                    if (monsters.length > 0) {
                        rawData[sheetName] = monsters;
                        loadedSheets++;
                    }
                }
            }
        });

        if (loadedSheets === 0) {
            alert("æ–‡ä»¶æ ¼å¼ä¸åŒ¹é…ï¼Œæœªæ‰¾åˆ°æœ‰æ•ˆçš„æ€ªç‰©æ•°æ®é¡µã€‚");
            return;
        }
        renderDungeonSelect();
        renderMonsterList();
    }

    function renderDungeonSelect() {
        const select = document.getElementById('dungeonSelect');
        select.innerHTML = '';
        const dungeons = Object.keys(rawData);
        
        dungeons.forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.text = key;
            select.appendChild(option);
        });
        
        if(dungeons.length > 0) renderMonsterList();
    }

    function renderMonsterList() {
        const dungeonName = document.getElementById('dungeonSelect').value;
        const listDiv = document.getElementById('monsterList');
        listDiv.innerHTML = '';
        
        if (!dungeonName || !rawData[dungeonName]) {
            listDiv.innerHTML = '<div style="text-align:center; padding:20px;">æ— æ•°æ®</div>'; return;
        }

        const seenNames = new Set();

        rawData[dungeonName].forEach(m => {
            const name = m.Name || 'æœªçŸ¥';
            if (seenNames.has(name)) return;
            seenNames.add(name);

            const btn = document.createElement('button');
            btn.className = 'monster-list-btn';
            const type = m.Type ? m.Type.trim() : 'æ€ªç‰©';
            const tagClass = type === 'é¦–é¢†' ? 'tag-boss' : 'tag-mob';
            
            btn.innerHTML = `
                <span style="font-weight:600">${name}</span>
                <span class="tag ${tagClass}">${type}</span>
            `;
            btn.onclick = () => {
                addCard(dungeonName, name);
                toggleDrawer(false); 
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            listDiv.appendChild(btn);
        });
    }

    function toggleDrawer(show) {
        const drawer = document.getElementById('bottomDrawer');
        const overlay = document.getElementById('drawerOverlay');
        if (show) {
            drawer.classList.add('active');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        } else {
            drawer.classList.remove('active');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }
    }

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šä¿®å¤è¯¯åˆ â€œç§»åŠ¨åŠ›â€æè¿°çš„Bug ---
    function parseEffect(effectStr, level) {
        if (!effectStr) return { atk: '-', range: '-', move: '-', hp: '-', desc: 'æ— ' };

        // åŸºç¡€æ•°å€¼è®¡ç®—å·¥å…·
        const calc = (formula) => {
            if (!formula) return '-';
            let strFormula = String(formula);
            strFormula = strFormula.replace(/ï¼ˆ/g, '(').replace(/ï¼‰/g, ')');
            let safeFormula = strFormula.replace(/(\d)X/gi, '$1*' + level).replace(/X/gi, level);
            try { return Math.floor(Function('"use strict";return (' + safeFormula + ')')()); } 
            catch (e) { return formula; }
        };

        const extract = (key) => {
            const regex = new RegExp(key + "[:ï¼š]?\\s*([0-9X\/\\*\\.\\+\\-\(\)]+)", "i");
            const match = effectStr.match(regex);
            return match ? match[1] : null;
        };

        const atk = calc(extract("æ”»å‡»åŠ›"));
        const range = calc(extract("å°„ç¨‹"));
        const move = calc(extract("ç§»åŠ¨åŠ›"));
        const hp = calc(extract("æœ€å¤§ç”Ÿå‘½"));

        // å¤„ç†æè¿°æ–‡æœ¬
        let desc = effectStr;

        // 1. ç§»é™¤å·²æå–çš„åŸºç¡€å±æ€§æ–‡æœ¬
        // ä¿®æ”¹ç­–ç•¥ï¼šä¸å†ä½¿ç”¨å…¨å±€æ›¿æ¢(g)ï¼Œè€Œæ˜¯é’ˆå¯¹æ¯ä¸ªå±æ€§ï¼Œåªç§»é™¤â€œç¬¬ä¸€ä¸ªâ€åŒ¹é…é¡¹ã€‚
        // è¿™æ ·å¯ä»¥ä¿ç•™åç»­æè¿°ä¸­å‡ºç°çš„â€œç§»åŠ¨åŠ›+1â€æˆ–â€œé€ æˆç§»åŠ¨åŠ›*2ä¼¤å®³â€ç­‰æ–‡æœ¬ã€‚
        const statsToRemove = ["æ”»å‡»åŠ›", "å°„ç¨‹", "ç§»åŠ¨åŠ›", "æœ€å¤§ç”Ÿå‘½"];
        statsToRemove.forEach(key => {
            // æ­£åˆ™ï¼šåŒ¹é… å±æ€§å + å¯é€‰å†’å· + æ•°å€¼å…¬å¼ + å¯é€‰æ ‡ç‚¹
            const regex = new RegExp(key + "[:ï¼š]?\\s*[0-9X\\*\\/\\.\\+\\-\\(\\)]+\\s*[ï¼Œ,ï¼›;ã€‚]?\\s*", "i");
            desc = desc.replace(regex, ""); // ä»…æ›¿æ¢ä¸€æ¬¡
        });
        
        desc = desc.replace(/ã€‚/g, '<br>'); 

        // 2. æ›¿æ¢æè¿°ä¸­çš„å…¬å¼ï¼ˆXå¤„ç†é€»è¾‘ï¼Œä¿ç•™ä¸Šä¸€ç‰ˆçš„ä¼˜åŒ–ï¼‰
        desc = desc.replace(/ï¼ˆ/g, '(').replace(/ï¼‰/g, ')');
        
        // æŸ¥æ‰¾å¹¶è®¡ç®—æè¿°ä¸­çš„æ•°å­¦å…¬å¼
        desc = desc.replace(/(?<![a-z])[0-9\+\-\*\/\.\(\)]*X[0-9\+\-\*\/\.\(\)]*(?![a-z])/gi, (match) => {
            try {
                let formula = match.replace(/(\d)X/gi, '$1*' + level); 
                formula = formula.replace(/X/gi, level);
                formula = formula.replace(/(\d)\(/g, '$1*(');
                let res = Function('"use strict";return (' + formula + ')')();
                return Math.floor(res);
            } catch (e) {
                return match;
            }
        });

        if (!desc.trim()) desc = "";

        return {
            atk, range, move, hp,
            rawHp: extract("æœ€å¤§ç”Ÿå‘½"),
            desc
        };
    }

    function sortCards() {
        const container = document.getElementById('cardsArea');
        const cards = Array.from(container.querySelectorAll('.card'));

        cards.sort((a, b) => {
            const dataA = activeCards[a.id];
            const dataB = activeCards[b.id];
            
            if (!dataA) return 1;
            if (!dataB) return -1;

            const agiA = parseFloat(dataA.baseData.Agility) || 0;
            const agiB = parseFloat(dataB.baseData.Agility) || 0;

            if (agiB !== agiA) return agiB - agiA;
            return 0;
        });

        cards.forEach(card => container.appendChild(card));
    }

    function changeLevel(delta) {
        const input = document.getElementById('levelInput');
        let val = parseInt(input.value) || 1;
        val += delta;
        if (val < 1) val = 1;
        input.value = val;
        updateAllCards();
    }

    function addCard(dungeonName, monsterName) {
        const monster = rawData[dungeonName].find(m => m.Name === monsterName);
        if (!monster) return;

        const level = parseInt(document.getElementById('levelInput').value) || 1;
        const stats = parseEffect(monster.Effect, level);
        const cardId = 'card-' + cardIdCounter++;
        
        activeCards[cardId] = {
            id: cardId,
            baseData: monster,
            currentHp: stats.hp !== '-' ? stats.hp : 0
        };

        renderCardDOM(cardId);
        sortCards();
        
        const emptyState = document.querySelector('.empty-state');
        if (emptyState) emptyState.style.display = 'none';
    }

    function renderCardDOM(cardId) {
        const data = activeCards[cardId];
        const m = data.baseData;
        const level = parseInt(document.getElementById('levelInput').value) || 1;
        const stats = parseEffect(m.Effect, level);

        let cardDiv = document.getElementById(cardId);
        if (!cardDiv) {
            cardDiv = document.createElement('div');
            cardDiv.id = cardId;
            const type = m.Type ? m.Type.trim() : 'æ€ªç‰©';
            cardDiv.className = type === 'é¦–é¢†' ? 'card boss-card' : 'card';
            
            const container = document.getElementById('cardsArea');
            if (container.firstChild) {
                container.insertBefore(cardDiv, container.firstChild);
            } else {
                container.appendChild(cardDiv);
            }
        }

        const existingInput = document.getElementById(`${cardId}-hp-input`);
        const inputValue = existingInput ? existingInput.value : 1;

        cardDiv.innerHTML = `
            <div class="card-header">
                <div>
                    <div class="card-title">${m.Name}</div>
                    <div class="card-meta">
                        <span class="meta-tag">æ•æ·: ${m.Agility || '-'}</span>
                        <span class="meta-tag">æ»ç•™: ${m.Retention || '0'}</span>
                    </div>
                </div>
                <button class="close-btn" onclick="removeCard('${cardId}')">Ã—</button>
            </div>

            <div class="stats-grid">
                <div class="stat-item"><span class="stat-label">æ”»å‡»</span> <span class="stat-value" style="color:#e53e3e">${stats.atk}</span></div>
                <div class="stat-item"><span class="stat-label">å°„ç¨‹</span> <span class="stat-value">${stats.range}</span></div>
                <div class="stat-item"><span class="stat-label">ç§»åŠ¨</span> <span class="stat-value">${stats.move}</span></div>
                <div class="stat-item"><span class="stat-label">ç”Ÿå‘½ä¸Šé™</span> <span class="stat-value">${stats.hp}</span></div>
            </div>

            <div class="hp-control">
                <div class="hp-display">
                    <span id="${cardId}-hp-val" style="${data.currentHp <= 0 ? 'color:red' : ''}">${data.currentHp}</span> 
                    <span style="font-size:0.6em; color:#aaa">/ ${stats.hp}</span>
                </div>
                <div class="hp-actions">
                    <button class="hp-btn damage" onclick="applyHpChange('${cardId}', -1)">-</button>
                    <input type="number" id="${cardId}-hp-input" value="${inputValue}" class="hp-input" min="1" onclick="this.select()">
                    <button class="hp-btn heal" onclick="applyHpChange('${cardId}', 1)">+</button>
                </div>
            </div>

            <div class="effect-text">
                <div style="font-weight:bold; margin-bottom:4px; font-size:0.85em; color:#d69e2e">ç‰¹æ€§æ•ˆæœ</div>
                ${stats.desc}
            </div>
        `;
    }

    function applyHpChange(cardId, multiplier) {
        if (!activeCards[cardId]) return;
        
        const m = activeCards[cardId].baseData;
        const level = parseInt(document.getElementById('levelInput').value) || 1;
        const stats = parseEffect(m.Effect, level);
        const maxHp = (typeof stats.hp === 'number') ? stats.hp : 999999;

        const inputEl = document.getElementById(`${cardId}-hp-input`);
        const val = parseInt(inputEl.value) || 0;
        const delta = val * multiplier;
        
        let newHp = activeCards[cardId].currentHp + delta;
        if (newHp > maxHp) newHp = maxHp; 

        activeCards[cardId].currentHp = newHp;
        
        const display = document.getElementById(cardId + '-hp-val');
        if(display) {
            display.innerText = activeCards[cardId].currentHp;
            display.style.color = activeCards[cardId].currentHp <= 0 ? 'red' : '#2d3748';
        }
        
        if (window.navigator && window.navigator.vibrate) {
            window.navigator.vibrate(30);
        }
    }

    function updateAllCards() {
        Object.keys(activeCards).forEach(id => {
            const data = activeCards[id];
            const level = parseInt(document.getElementById('levelInput').value) || 1;
            const stats = parseEffect(data.baseData.Effect, level);
            
            if (typeof stats.hp === 'number' && data.currentHp > stats.hp) {
                data.currentHp = stats.hp;
            }

            renderCardDOM(id);
        });
        sortCards(); 
    }

    function removeCard(cardId) {
        delete activeCards[cardId];
        const el = document.getElementById(cardId);
        if (el) {
            el.style.transform = 'translateX(100%)';
            el.style.opacity = '0';
            setTimeout(() => {
                el.remove();
                if (Object.keys(activeCards).length === 0) {
                    const empty = document.querySelector('.empty-state');
                    if(empty) empty.style.display = 'block';
                }
            }, 200);
        }
    }
</script>

</body>
</html>
